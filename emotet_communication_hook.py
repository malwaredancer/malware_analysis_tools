# 
# malwaredancer.com
#
# -*- coding: utf-8 -*-
from pydbg import *
from pydbg.defines import *

import struct
import utils
import sys
import binascii
import time
import re

def httpsendrequest_sniff(dbg, args):
    lpszHeaders = args[1]
    dwHeadersLength = args[2]
    lpOptional = args[3]
    dwOptionalLength = args[4]

    headers_buf = ""
    post_buf = ""
    print(hex(dwHeadersLength))
    i=0
    while True:
        byte = dbg.read_process_memory(lpszHeaders+i, 2)
        if byte == b'\x00\x00':
            break
        headers_buf += byte
	i += 2

    print("httpsendrequest lpszHeaders: ", headers_buf.replace(b'\x00', ''))
    i=0
    while True:
        byte = dbg.read_process_memory(lpOptional+i, 1)
        if byte == '\x00':
            break
        post_buf += byte
	i += 1

    print("lpOptional ", post_buf)
    return DBG_CONTINUE

def crypt_import_key_sniff(dbg, args):
    pbDataPtr = args[1]
    dwDataLen = args[2]

    print("CryptImportKey dwDataLen:"+str(dwDataLen))

    pbData = ""
    for i in range(0, dwDataLen):
        byte = dbg.read_process_memory(pbDataPtr+i, 1)
        pbData += byte
    print("CryptImportKey pbData: "+pbData)
    print(binascii.hexlify(pbData))
    return DBG_CONTINUE

def crypt_decrypt_sniff_on_entry(dbg, args):
    pbDataPtr = args[4]
    pdwDataLenPtr = args[5]
    buffer = ""

    pdwDataLen = dbg.read_process_memory(pdwDataLenPtr, 4)

    for i in range(0, struct.unpack('<i', pdwDataLen)[0]):
        byte = dbg.read_process_memory(pbDataPtr+i, 1)
	buffer += byte
    return DBG_CONTINUE

def crypt_decrypt_sniff_on_exit(dbg, args, return_value):
    pbDataPtr = args[4]
    pdwDataLenPtr = args[5]

    pdwDataLen = dbg.read_process_memory(pdwDataLenPtr, 4)
    #pdData = dbg.read_process_memory(pbData, pdwDataLen)

    buffer = ""

    for i in range(0, struct.unpack('<i', pdwDataLen)[0]):
        byte = dbg.read_process_memory(pbDataPtr+i, 1)
	buffer += byte

    if struct.unpack('<i', pdwDataLen)[0] > 100:
        open(time.time(), 'wb').write(buffer)

    print("CryptDecrypt on exit pbData:", buffer)
    print(binascii.hexlify(bytearray(buffer)))
    return DBG_CONTINUE

def crypt_encrypt_sniff(dbg, args):
    original_machine_bot_id = b'WIN10PC_XXXXXXXX'
    changed_machine_bot_id = b'WIN10PC_XXXXXXXX'

    pbData = args[4]
    pdwDataLen = args[6]
    buffer = ""

    for i in range(0, pdwDataLen):
        byte = dbg.read_process_memory(pbData+i, 1)
        buffer += byte

    buffer = buffer.replace(original_machine_bot_id, changed_machine_bot_id)

    for i in range(pdwDataLen):
        dbg.write_process_memory(pbData+i, buffer[i])

    print("CryptEncrypt pbData: ", buffer)
    print(binascii.hexlify(bytearray(buffer)))
    return DBG_CONTINUE

def get_pid_for_proc_name(proc_name):
    for i in range(3):
        for (pid, name) in dbg.enumerate_processes():
            if name.lower() == search_process:
                return pid
    print("Cannot find %s process. Exiting..." % proc_name)
    sys.exit(-1)

def hook_call(dbg, hook_container, module_name, symbol, entry_hook, exit_hook, number_of_args):
    hook_address = dbg.func_resolve_debuggee(module_name, symbol)
    if hook_address:
        hook_container.add(dbg, hook_address, number_of_args, entry_hook, exit_hook)
        print("%s.%s hooked at 0x%08x" % (module_name, symbol, hook_address))
    else:
        print("Cannot resolve hook address for %s.%s" % (module_name, symbol))
        sys.exit(-1)

if __name__ == "__main__":

    dbg = pydbg()

    if len(sys.argv) < 2:
        print "Run it like 'python hook.py emotet_process_name.exe"
        exit(1)

    search_process = sys.argv[1]

    hooks = utils.hook_container()
    pid = get_pid_for_proc_name(search_process)

    dbg.attach(pid)
    print("[*] Attaching to emotet with PID: %d" % pid)

    hook_call(dbg, hooks, 'wininet.dll', 'HttpSendRequestW', httpsendrequest_sniff, None, 5)
    hook_call(dbg, hooks, 'cryptsp.dll', 'CryptEncrypt', crypt_encrypt_sniff, None, 7)
    hook_call(dbg, hooks, 'cryptsp.dll', 'CryptDecrypt', crypt_decrypt_sniff_on_entry, crypt_decrypt_sniff_on_exit, 6)
    hook_call(dbg, hooks, 'cryptsp.dll', 'CryptImportKey', crypt_import_key_sniff, None, 6)
    hook_call(dbg, hooks, 'wininet.dll', 'HttpSendRequestW', httpsendrequest_sniff, None, 5)


    print("[*] Hooks set, continuing process.")
    dbg.run()
