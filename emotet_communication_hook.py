# 
# malwaredancer.com
#
# -*- coding: utf-8 -*-
from pydbg import *
from pydbg.defines import *

import struct
import utils
import sys
import binascii
import time

def crypt_decrypt_sniff_on_entry(dbg, args):
    pbDataPtr = args[4]
    pdwDataLenPtr = args[5]
    buffer = ""

    pdwDataLen = dbg.read_process_memory(pdwDataLenPtr, 4)

    for i in range(0, struct.unpack('<i', pdwDataLen)[0]):
        byte = dbg.read_process_memory(pbDataPtr+i, 1)
	buffer += byte
    return DBG_CONTINUE

def crypt_decrypt_sniff_on_exit(dbg, args, return_value):
    pbDataPtr = args[4]
    pdwDataLenPtr = args[5]

    pdwDataLen = dbg.read_process_memory(pdwDataLenPtr, 4)

    buffer = ""

    for i in range(0, struct.unpack('<i', pdwDataLen)[0]):
        byte = dbg.read_process_memory(pbDataPtr+i, 1)
	buffer += byte

    if struct.unpack('<i', pdwDataLen)[0] > 100:
        open(time.time(), 'wb').write(buffer)

    print("CryptDecrypt on exit pbData:", buffer)
    print(binascii.hexlify(bytearray(buffer)))
    return DBG_CONTINUE

def crypt_encrypt_sniff(dbg, args):

    pbData = args[4]
    pdwDataLen = args[6]
    bufferLen = int(pdwDataLen)
    buffer = ""

    for i in range(0, pdwDataLen):
        byte = dbg.read_process_memory(pbData+i, 1)
        buffer += byte

    print("CryptEncrypt pbData: ", buffer)
    print(binascii.hexlify(bytearray(buffer)))
    return DBG_CONTINUE

def get_pid_for_proc_name(proc_name):
    for (pid, name) in dbg.enumerate_processes():
        if name.lower() == search_process:
            return pid
    print("Cannot find %s process. Exiting..." % proc_name)
    sys.exit(-1)

def hook_call(dbg, hook_container, module_name, symbol, entry_hook, exit_hook, number_of_args):
    hook_address = dbg.func_resolve_debuggee(module_name, symbol)
    if hook_address:
        hook_container.add(dbg, hook_address, number_of_args, entry_hook, exit_hook)
        print("%s.%s hooked at 0x%08x" % (module_name, symbol, hook_address))
    else:
        print("Cannot resolve hook address for %s.%s" % (module_name, symbol))
        sys.exit(-1)

if __name__ == "__main__":

    dbg = pydbg()

    if len(sys.argv) < 2:
        print "Run it like 'python hook.py emotet_process_name.exe"
        exit(1)

    search_process = sys.argv[1]

    hooks = utils.hook_container()
    pid = get_pid_for_proc_name(search_process)

    dbg.attach(pid)
    print("[*] Attaching to emotet with PID: %d" % pid)

    hook_call(dbg, hooks, 'cryptsp.dll', 'CryptEncrypt', crypt_encrypt_sniff, None, 7)
    hook_call(dbg, hooks, 'cryptsp.dll', 'CryptDecrypt', crypt_decrypt_sniff_on_entry, crypt_decrypt_sniff_on_exit, 6)

    print("[*] Hooks set, continuing process.")
    dbg.run()
